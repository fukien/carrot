<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>cbp2make: lib/stringhash.cpp File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">cbp2make
   </div>
   <div id="projectbrief">Makefile generation tool for Code::Blocks IDE</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&#160;List</span></a></li>
      <li><a href="../../globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">stringhash.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="../../d2/d7f/stringhash_8h_source.html">stringhash.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7573c6dc12bbf971c13ec76b36846d7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#a7573c6dc12bbf971c13ec76b36846d7f">add_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size)</td></tr>
<tr class="memdesc:a7573c6dc12bbf971c13ec76b36846d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additive hash.  <a href="#a7573c6dc12bbf971c13ec76b36846d7f">More...</a><br/></td></tr>
<tr class="separator:a7573c6dc12bbf971c13ec76b36846d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9da65bc56c5db07e2f3eb4b344ae04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#a3b9da65bc56c5db07e2f3eb4b344ae04">xor_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size)</td></tr>
<tr class="memdesc:a3b9da65bc56c5db07e2f3eb4b344ae04"><td class="mdescLeft">&#160;</td><td class="mdescRight">XOR hash.  <a href="#a3b9da65bc56c5db07e2f3eb4b344ae04">More...</a><br/></td></tr>
<tr class="separator:a3b9da65bc56c5db07e2f3eb4b344ae04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36397384816aeaa8e6a566936ec7ac0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#ac36397384816aeaa8e6a566936ec7ac0">rot_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size)</td></tr>
<tr class="memdesc:ac36397384816aeaa8e6a566936ec7ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotating hash.  <a href="#ac36397384816aeaa8e6a566936ec7ac0">More...</a><br/></td></tr>
<tr class="separator:ac36397384816aeaa8e6a566936ec7ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70614aa755c088429499779b536c762f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#a70614aa755c088429499779b536c762f">djb_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size)</td></tr>
<tr class="memdesc:a70614aa755c088429499779b536c762f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bernstein hash.  <a href="#a70614aa755c088429499779b536c762f">More...</a><br/></td></tr>
<tr class="separator:a70614aa755c088429499779b536c762f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c6a13eca64836b03a30792d4007259"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#a33c6a13eca64836b03a30792d4007259">djb2_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size)</td></tr>
<tr class="memdesc:a33c6a13eca64836b03a30792d4007259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Bernstein hash.  <a href="#a33c6a13eca64836b03a30792d4007259">More...</a><br/></td></tr>
<tr class="separator:a33c6a13eca64836b03a30792d4007259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e669376ac32d75888a832f291efc38f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#a4e669376ac32d75888a832f291efc38f">sax_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size)</td></tr>
<tr class="memdesc:a4e669376ac32d75888a832f291efc38f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift-Add-XOR hash.  <a href="#a4e669376ac32d75888a832f291efc38f">More...</a><br/></td></tr>
<tr class="separator:a4e669376ac32d75888a832f291efc38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c269a9949a48c06f7b6647deda9fd11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#a2c269a9949a48c06f7b6647deda9fd11">fnv_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size)</td></tr>
<tr class="memdesc:a2c269a9949a48c06f7b6647deda9fd11"><td class="mdescLeft">&#160;</td><td class="mdescRight">FNV hash.  <a href="#a2c269a9949a48c06f7b6647deda9fd11">More...</a><br/></td></tr>
<tr class="separator:a2c269a9949a48c06f7b6647deda9fd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c384ed43ac9f502055b689aacde1f19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#a1c384ed43ac9f502055b689aacde1f19">oat_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size)</td></tr>
<tr class="memdesc:a1c384ed43ac9f502055b689aacde1f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-at-a-Time hash.  <a href="#a1c384ed43ac9f502055b689aacde1f19">More...</a><br/></td></tr>
<tr class="separator:a1c384ed43ac9f502055b689aacde1f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d67e521fccfb371e411e72812f36c6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#a0d67e521fccfb371e411e72812f36c6b">jsw_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size, const <a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a> *magic)</td></tr>
<tr class="memdesc:a0d67e521fccfb371e411e72812f36c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">JSW hash.  <a href="#a0d67e521fccfb371e411e72812f36c6b">More...</a><br/></td></tr>
<tr class="separator:a0d67e521fccfb371e411e72812f36c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15ec088c9489c19a9f13720e66c695b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#ab15ec088c9489c19a9f13720e66c695b">elf_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size)</td></tr>
<tr class="memdesc:ab15ec088c9489c19a9f13720e66c695b"><td class="mdescLeft">&#160;</td><td class="mdescRight">ELF hash.  <a href="#ab15ec088c9489c19a9f13720e66c695b">More...</a><br/></td></tr>
<tr class="separator:ab15ec088c9489c19a9f13720e66c695b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a819f6d3a58abfc276ffcdc89f2023"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#a65a819f6d3a58abfc276ffcdc89f2023">jen_mix</a> (<a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a> &amp;a, <a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a> &amp;b, <a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a> &amp;c)</td></tr>
<tr class="separator:a65a819f6d3a58abfc276ffcdc89f2023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363e65ffe5c9b0d5bcfc63d503b92938"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#a363e65ffe5c9b0d5bcfc63d503b92938">jen_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size, const <a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a> magic)</td></tr>
<tr class="memdesc:a363e65ffe5c9b0d5bcfc63d503b92938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jenkins hash.  <a href="#a363e65ffe5c9b0d5bcfc63d503b92938">More...</a><br/></td></tr>
<tr class="separator:a363e65ffe5c9b0d5bcfc63d503b92938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac633b93854f2d2749a59de4fe75f741f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/stringhash_8cpp.html#ac633b93854f2d2749a59de4fe75f741f">sdbm_hash</a> (const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *data, const size_t size)</td></tr>
<tr class="memdesc:ac633b93854f2d2749a59de4fe75f741f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public-domain reimplementation of NDBM hash.  <a href="#ac633b93854f2d2749a59de4fe75f741f">More...</a><br/></td></tr>
<tr class="separator:ac633b93854f2d2749a59de4fe75f741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7573c6dc12bbf971c13ec76b36846d7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">add_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Additive hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>Probably the simplest algorithm for hashing a sequence of integral values (such as a string), is to add all of the characters together and then force the range into something suitable for lookup with the remainder of division. I will give an example of this algorithm only because books commonly suggest it in their rush to get past the topic of hash functions on their way to collision resolution methods. This algorithm is very bad.</p>
<p>Generally, any hash algorithm that relies primarily on a commutitive operation will have an exceptionally bad distribution. This hash fails to treat permutations differently, so “abc”, “cba”, and “cab” will all result in the same hash value.</p>
<p>Despite the suckiness of this algorithm, the example is useful in that it shows how to create a general hash function. add_hash can be used to hash strings, single integers, single floating-point values, arrays of scalar values, and just about anything else you can think of because it is always legal to pun a simple object into an array of unsigned char and work with the individual bytes of the object. </p>

</div>
</div>
<a class="anchor" id="a33c6a13eca64836b03a30792d4007259"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">djb2_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modified Bernstein hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>A minor update to Bernstein's hash replaces addition with XOR for the combining step. This change does not appear to be well known or often used, the original algorithm is still recommended by nearly everyone, but the new algorithm typically results in a better distribution. </p>

</div>
</div>
<a class="anchor" id="a70614aa755c088429499779b536c762f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">djb_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bernstein hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>Professor Dan Bernstein created this algorithm and posted it in a comp.lang.c newsgroup. It is known by many as the Chris Torek hash because Chris went a long way toward popularizing it. Since then it has been used successfully by many, but despite that the algorithm itself is not very sound when it comes to avalanche and permutation of the internal state. It has proven very good for small character keys, where it can outperform algorithms that result in a more random distribution.</p>
<p>Bernstein's hash should be used with caution. It performs very well in practice, for no apparently known reasons (much like how the constant 33 does better than more logical constants for no apparent reason), but in theory it is not up to snuff. Always test this function with sample data for every application to ensure that it does not encounter a degenerate case and cause excessive collisions. </p>

</div>
</div>
<a class="anchor" id="ab15ec088c9489c19a9f13720e66c695b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">elf_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ELF hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>The ELF hash function has been around for a while, and it is believed to be one of the better algorithms out there. In my experience, this is true, though ELF hash does not perform sufficiently better than most of the other algorithms presented in this tutorial to justify its slightly more complicated implementation. It should be on your list of first functions to test in a new lookup implementation. </p>

</div>
</div>
<a class="anchor" id="a2c269a9949a48c06f7b6647deda9fd11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fnv_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FNV hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>The FNV hash, short for Fowler/Noll/Vo in honor of the creators, is a very powerful algorithm that, not surprisingly, follows the same lines as Bernstein's modified hash with carefully chosen constants. This algorithm has been used in many applications with wonderful results, and for its simplicity, the FNV hash should be one of the first hashes tried in an application. </p>

</div>
</div>
<a class="anchor" id="a363e65ffe5c9b0d5bcfc63d503b92938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jen_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a>&#160;</td>
          <td class="paramname"><em>magic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Jenkins hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
    <tr><td class="paramname">magic</td><td>a random number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>The dreaded Jenkins hash has been thoroughly tested and passes all kinds of tests for avalanche and permutations. As such it is considered to be one of the best and most thoroughly analyzed algorithms. Unfortunately, it is also ridiculously complicated compared to the other hashes. </p>

</div>
</div>
<a class="anchor" id="a65a819f6d3a58abfc276ffcdc89f2023"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jen_mix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d67e521fccfb371e411e72812f36c6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jsw_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#a488906826f8aaf7e850c35889d560089">hash_t</a> *&#160;</td>
          <td class="paramname"><em>magic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>JSW hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
    <tr><td class="paramname">magic</td><td>table of random numbers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>This is a hash of my own devising that combines a rotating hash with a table of randomly generated numbers. The algorithm walks through each byte of the input, and uses it as an index into a table of random integers generated by a good random number generator. The internal state is rotated to mix it up a bit, then XORed with the random number from the table. The result is a uniform distribution if the random numbers are uniform. The size of the table should match the values in a byte. For example, if a byte is eight bits then the table would hold 256 random numbers. </p>

</div>
</div>
<a class="anchor" id="a1c384ed43ac9f502055b689aacde1f19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">oat_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One-at-a-Time hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>Bob Jenkins is a well known authority on designing hash functions for table lookup. In fact, one of his hashes is considered state of the art for lookup, which we will see shortly. A considerably simpler algorithm of his design is the One-at-a-Time hash.</p>
<p>This algorithm quickly reaches avalanche and performs very well. This function is another that should be one of the first to be tested in any application, if not the very first. This algorithm has seen effective use in several high level scripting languages as the hash function for their associative array data type. </p>

</div>
</div>
<a class="anchor" id="ac36397384816aeaa8e6a566936ec7ac0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rot_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotating hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>The rotating hash is identical to the XOR hash except instead of simply folding each byte of the input into the internal state, it also performs a fold of the internal state before combining it with the each byte of the input. This extra mixing step is enough to give the rotating hash a much better distribution. Much of the time, the rotating hash is sufficient, and can be considered the minimal acceptable algorithm. Notice that with each improvement, the internal state is being mixed up more and more. This is a key element in a good hash function. </p>

</div>
</div>
<a class="anchor" id="a4e669376ac32d75888a832f291efc38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sax_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift-Add-XOR hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>The shift-add-XOR hash was designed as a string hashing function, but because it is so effective, it works for any data as well with similar efficiency. The algorithm is surprisingly similar to the rotating hash except a different choice of constants for the rotation is used, and addition is a preferred operation for mixing. All in all, this is a surprisingly powerful and flexible hash. Like many effective hashes, it will fail tests for avalanche, but that does not seem to affect its performance in practice. </p>

</div>
</div>
<a class="anchor" id="ac633b93854f2d2749a59de4fe75f741f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sdbm_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public-domain reimplementation of NDBM hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b9da65bc56c5db07e2f3eb4b344ae04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xor_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d7f/stringhash_8h.html#adb5f3584b941a8dc0fed6b7302b4b8eb">data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>XOR hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input array (string). </td></tr>
    <tr><td class="paramname">size</td><td>size of input array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>hash digest.</dd></dl>
<p>The XOR hash is another algorithm commonly suggested by textbooks. Instead of adding together the bytes of an object as the additive hash does, the XOR hash repeatedly folds the bytes together to produce a seemingly random hash value.</p>
<p>Unfortunately, this algorithm is too simple to work properly on most input data. The internal state, the variable h, is not mixed nearly enough to come close to achieving avalanche, nor is a single XOR effective at permuting the internal state, so the resulting distribution, while better than the additive and multiplicative hashes, is still not very good. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jun 9 2013 10:55:54 for cbp2make by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
